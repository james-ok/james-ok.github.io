---
title: 并发编程基础
date: 2019-12-28 09:33:20
categories: 并发编程
tags:
- JMM(Java Memory Model)
- Volatile
- 多线程
---
高并发一词是每个程序员都耳熟的一个词，但又有多少人接触过，或者说理解其底层原理呢，似乎这个概念已经成为了评判一个程序员等级的标准。今天我们来探索一下Java并发编程中的奥秘

## 内存模型的基本概念
计算机的每一个操作都是由CPU去执行的，而在执行的过程中，难免会有一些数据的读取和写入操作，这些数据是存在于我们的主存（物理内存）中的，然而主存的输入输出速度和CPU执行执行的速度相比要慢得多，
如果CPU的每次执行都要从主存中的加载写入数据，那么整个系统的性能就被降低了，所以，CPU就内置了高速缓存。
CPU在执行指令之前，会将需要用到的数据提前复制一个副本到高速缓存，然后CPU在运算过程中就可以直接读取和写入高速缓存中的副本数据，最后，运算结束，在退出指令之前将副本数据刷新到主存中。
例如：
```java
i = i + 1;
```
在以上操作中，CPU会首先从主存中读取i的值，并且将其复制到CPU的高速缓存中，如果此时i的值为0，那么高速缓存中就存在一个i=0的变量，再执行i+1，得到结果为1，最后在退出指令之前将i的值1刷新到主存中。
以上操作在单线程中没有任何问题，但多线程就会出现问题，在多核CPU中，每条线程可能会在不同的CPU中运行，各个CPU有独立的高速缓存，此时两个线程同时执行以上操作，线程1在执行指令之前会将i的值0复制到
CPU1的高速缓存中，线程2也同样将i的值0复制到CPU2的高速缓存中，此时两个线程中i的值都为0，然后开始运算，线程1运算完成后得到i的值为1，在其执行完指令退出前，将缓存中的值刷新到主存中；线程2运算完成
后得到i的值也为1，将其刷新到主存中，这个时候主存中i的值为1，并不是我们理想中的2。这就是著名的缓存一致性问题，我们通常称多个线程访问的变量为共享变量。也就是说，一个变量存在于多个CPU的高速缓存中
就会出现缓存一致性问题。
那么为了解决缓存一致性问题，一般有以下两种方案：
* 总线锁：早期的CPU都是通过在总线上加锁#Lock来解决的，因为CPU和其他部件都是通过总线来进行的，在总线上加锁，也就保证了CPU的多个核心串行执行，当线程1执行完再执行线程2。这虽然解决了缓存一致性问题
但是该种方式带来的效率低下是无法避免的。
* 缓存一致性协议：由于总线锁方式的效率低下，所以就出现了缓存一致性协议，最出名的就是Intel的MESI协议，它的核心思想是：当其中一个CPU在写某个变量时，如果发现该变量是共享变量（该变量存在于多个CPU
的高速缓存中），则通知其他CPU将该变量的缓存状态设置为失效，当其他CPU需要读取该变量时，发现该变量缓存是失效状态的，所以会重新从主存中读取。

## 并发编程的三个概念
明白了计算机的内存模型，现在来分析一下我们在日常开发过程中，并发编程需要面临的三个问题：可见性问题、原子性问题、有序性问题

### 可见性
多个线程访问同一个变量，一个线程对该变量的值进行了改变，其他线程能够立即看到该变量的最新数据。
当一个变量存在于多个CPU中的高速缓存中，一个线程对该变量进行了变更，其他线程中任然是该变量变更之前的数据，这个时候就出现了可见性问题。

### 原子性
一个或者多个操作，要么全部执行，执行过程中不会被其他线程打断，要么全部不执行。只有保证了原则性，才能确保得到的结果是正确的。
例如：一个32位变量的赋值分为两个步骤，为低16位赋值，为高16位赋值；当将低16位的值写入成功过后，突然中断，此时有一个线程对该变量进行了访问，这个时候得到的结果是不正确的，这就出现了原子性问题

### 有序性
程序的执行顺序按照代码的编写先后顺序执行。
处理器为了提高程序执行效率，可能会对程序代理进行优化，它不保证每句代理的执行的顺序，但可以保证程序最终执行的结果是一致的。这就是指令重排序，那么它是怎么保证最后结果的一致性的呢？举个例子：
```java
int i = 1; //{1}
int j = 2; //{2}
i = i + 1; //{3}
j = j + i; //{4}
```
以上代码执行顺序可以是：{2} -> {1} -> {3} -> {4}，但是绝对不会出现 {2} -> {1} -> {4} -> {3}，因为步骤{4}依赖于步骤{3}的执行结果。
从上面的例子可以看出，指令重排序并不会影响单线程的执行结果，但是在多线程就不一定了，例如（伪代码）：
```java
//线程1
Object a = new Object();    //{1}
flag = false;               //{2}

//线程2
while(flag) {               //{3}
    Thread.sleep(1000);
}
a.test();                   //{4}
```
从以上例子可以看出，线程1中，代码{1}和代码{2}并没有依赖性，所以根据执行重排序的规则，{1}{2}并不保证执行的顺序性，这个时候如果首先执行的是{2}，那么线程2就会终止循环结束线程，执行{4}，然而这个时候a
还没有完成初始化，这个时候程序就会抛出异常。

### 总结
要想在多线程中程序的正常执行，必须要保证可见性、原子性、有序性。

## Java内存模型（JMM）
前面两节了解了计算机的内存模型，下面来了解一下Java的内存模型。它为我们提供了哪些保证以及提供了哪些方法或者机制来解决以上问题。
JMM主要是为了屏蔽各个硬件平台和操作系统对内存访问的差异，实现JVM在各个平台下能一致的访问内存的功能。他主要定义了程序中变量的访问规则，值得注意的是，JMM为了较好的执行性能，并没有限制CPU使用高速
缓存带来的性能优化，也没有限制编译器对指令的重排序，也就是说，在JMM模型中，任然存在缓存一致性和指令重排序问题。
JMM模型中，所有的变量都存在于主存（可以看成是物理内存）中，每个线程都有自己的工作内存（可以看成是CPU的高速缓存）中，线程对变量的每个操作都是在自己的工作内存中，不能直接对主存进行操作，并且各个线程
不能对其他线程的工作内存中的数据进行操作。


## Volatile关键字