---
title: 算法和数据结构
date: 2020-03-10 17:12:23
categories: 数据结构
tags:
- 算法
- 数据结构
- 树
---
很多同学一问到数据结构或者说算法都会觉得很难，不好理解，那么今天我们就来好好学习它。

## 时间和空间复杂度
程序是用来解决问题的，而解决问题的思路或者方法有很多种，每一种方式方法都有它的好处与坏处，每种方法在时间和空间上的消耗不尽相同，所以我们只有了解了什么是时间和空间复杂的并且掌握如何
来评估某种方式方法在时间和空间上的复杂度过后我们才能衡量当前这种方式的优劣程度，最后进行比较，最终选择最优的实现方式来解决问题。

### 时间复杂度
时间复杂度推导原则：
* 如果运行时间是常数量级，则用1表示
* 只保留时间函数中最高阶项，例如：T(n)=0.5n^2+0.5n中最高阶项是0.5n^2
* 如果最高阶项存在，则省去前面的系数
常见的时间复杂度量有(通过从小到大顺序排列)：
* O(1)：常量阶，运行时间为常量
* O(logn)：对数阶，如二分查找法
* O(n)：线性阶，如n个数内找最大值
* O(nlogn)：对数阶，如快速排序算法
* O(n^2)：平方阶，如选择排序，冒泡排序，需要双重循环
* O(n^3)：立方阶，如两个n阶矩阵的乘法运算
* O(2^n)：指数阶，如n个元素集合的所有子集的算法
* O(n!)：阶乘阶，如n个元素全部排列的算法

### 空间复杂度

## 数组、链表、跳表
* 数组在内存中开辟一块连续的内存空间，并在此空间中存放数据，数组的特点是读取较快，写入较慢。数组从头插入和从尾部插入的时间复杂度是O(1)，但是从指定下标开始插入，由于需要挪动后面的元素
所有时间复杂度是O(n)，但是读取就很快了，直接通过下标就能直接返回，时间复杂度是O(1)
* 链表可以分为单链表循环链表和双向链表，java中LinkedList就是一个标准的双向链表，特点是增删改比较快，读取较慢。链表的元素添加只需要将需要插入位置的前一个节点的next指针指向需要添加的元素上，
然后将当前元素的next指针指向指向当前节点的节点原本的next地址。删除一个元素只需要将当前节点的前一个节点的next指针指向当前节点的next指针地址，查询需要从头节点开始一个一个往下找。
链表的增删改在时间复杂度上是O(1)，但是查询的时间复杂度是O(0)
* 跳表是为了优化链表的查询缺陷，实际上是一种空间换时间的思维方式。通过增加多级索引的方式来达到快速查找，索引的每一级是上一级索引的两倍2-4-8-16。跳表在时间复杂度上就是O(logn)，
空间复杂度为O(n)

## 栈、队列
* 栈的特点是先进后出，可以将栈看成是一个桶，先放的东西在下面，而我们只能从上面开始拿东西。一般用于有较强顺序相关性的场景（例如，编译器符号开闭语法检测），栈的操作只有两种，压入栈和弹出栈，
且只能操作栈顶，只有栈顶元素是可访问的。栈的实现由两种，链表和数组。
* 队列特点是先进先出，队列在生活中场景就是排队，队列一般由数组和链表实现。

## 哈希表
哈希表也称散列表，是将关键码（key）进行Hash得到表中一个位置（下标）来直接访问的，这个函数称为哈希函数。一个简单的hash函数是将一个字符串中的每一个字符的ASCII码加在一起然后在mod上一个数
来得到它的hashcode，在java中有一个HashCode函数，不同的字符串通过哈希函数计算出来的结果有可能相同，这种现象我们称之为哈希碰撞，这种想象很常见，那么如果出现哈希碰撞一般会怎么解决呢，在java中
是通过新增了一个维度，也就是在相同的位置新增一个链表，这种方式称为拉链式解决冲突法，但是这种方式有个不好之处在于在查询数据的时候之前可以直接通过hash函数直接读取，现在通过hash过后还需要
在链表上便利，时间复杂度从O(1)升至O(n)。

## 二叉树
* 二叉树：也就是他的儿子节点只有两个（左子树和右子树），且树的叶子节点不会指向父节点或者兄弟节点（没有环，有环的称为图），一棵满二叉树树有多少个节点可以用公式`n = (2^k)-1`计算得出，其中n表示它的节点数，
k表示它的深度
* 二叉搜索树（二叉查找树）：在普通二叉树的基础上，各个节点的所有左子树的数据小于根节点，各个节点的所有右子树的数据大于根节点。

## 递归
函数直接或者间接的调用自身函数，那么我们称该函数为递归函数
树的遍历通常使用递归的方式遍历，一般分为前序遍历，中序遍历，后序遍历。递归方法有四个部分组成，递归终结、逻辑、递归到下一层、数据清理

## 分治和回溯


## 深度优先(DFS)和广度优先(BFS)
深度优先和广度优先算法是针对图和树的查找算法